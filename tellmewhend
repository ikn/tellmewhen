#! /usr/bin/env python3

import sys
import os
import signal
import socketserver
import threading
import queue

import tellmewhenlib
option_defns = tellmewhenlib.option.option_defns

# TODO:
# - documentation (--help, readme (windows: recommend ahk/cmdmp3win.exe))
# - makefile, etc.
# - better error messages on config validation
# - cli: host/port as options
# - consistent logging, with accurate timestamps


def on_quit (options, queue, thread, server):
    queue.put('quit')
    thread.join()
    server.server_close()
    sys.exit(0)


class RequestHandler(socketserver.BaseRequestHandler):
    def __init__ (self, queue, *args, **kwargs):
        self._queue = queue
        socketserver.BaseRequestHandler.__init__(self, *args, **kwargs)

    def invalid (self, msg):
        print('received invalid request:', msg, file=sys.stderr)

    def handle (self):
        raw_data, socket = self.request
        try:
            data = raw_data.decode('utf-8')
        except UnicodeDecodeError:
            self.invalid('not valid UTF-8')
        import time
        self._queue.put(data)
        socket.sendto(b'ack\n', self.client_address)


if __name__ == '__main__':
    event_defns, options = tellmewhenlib.cli.parse_args()
    queue = queue.Queue()
    thread = threading.Thread(target=tellmewhenlib.worker.run,
                            args=(event_defns, options, queue))
    server = socketserver.UDPServer(
        (options[option_defns.socket_host], options[option_defns.socket_port]),
        lambda *args, **kwargs: RequestHandler(queue, *args, **kwargs))

    for sig in (signal.SIGTERM, signal.SIGINT):
        signal.signal(sig, lambda *args: on_quit(options, queue, thread, server))

    thread.start()
    server.serve_forever()
